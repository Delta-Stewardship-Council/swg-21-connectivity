---
title: "make_gam_byregion"
author: "NCEAS Connectivity Group"
date: '2022-07-12'
output: html_document
editor_options: 
  chunk_output_type: console
---
This code runs gams by region, looking at the relationship between various covariates and chla. 


Questions/Notes:

1. For inundation filtering, do we want to do this for each region separately or use the min and max overall? 
2. Are we filtering inundation for upstream?
3. We didn't model upstream yet, right? 
4. Add other figures to look at beginning and end of flooding?
5. Can we turn some of this code into functions to reduce repetition?
6. Rename repeated variables - I tried to do this for some of it, but needs checking.
7. Nutrients
8. Inundation metrics



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#detach(gam)
library(dplyr)
library(readr)
library(lubridate)
library(glue)
library(tidyr)
library(zoo)
library(car)
library(MuMIn)
library(psych)
library(mgcv)
library(ggplot2)
library(viridis)
library(nlme)
library(kader)#cuberoot
library(mgcv)

# tinytex::install_tinytex() - run in console before knitting
```

# Read in data
```{r}

alldata <- read_csv("data_model/model_chla_covars_gam.csv") %>%
  mutate(month = lubridate::month(date),
         year  = lubridate::year(date),
         rdoy  = lubridate::yday(date) + 92,
         week  = lubridate::week(date),
         water_year = ifelse(month > 9, year + 1, year),
         dowy = ifelse(rdoy > 366, rdoy - 366, rdoy),
         log_chla = log(chlorophyll),
         log_idys = log(inund_days + 1),
         t_qsdy = kader:::cuberoot(Q_sday), 
         log_qsdy = log(Q_sday),
         inund_fac = ifelse(inund_days == 0, "none", ifelse(inund_days > 14, "long", "short")),
         inundation = as.factor(inundation),
         station_wq_chl = as.factor(station_wq_chl),
         inund_fac = as.factor(inund_fac)) %>%
  rename(station  = station_wq_chl)

```

## Downstream

### Filter to downstream

```{r}
downstream <- alldata %>% filter(region == "below")
```

```{r}
downstream_scaled <- downstream %>%
  mutate(across(.cols = c(log_idys,log_qsdy,diurnal_range:Sradmwk), ~ scale(.x)))
  
d <- downstream_scaled

downstream_s_long <- pivot_longer(d, cols = c(log_idys,t_qsdy,diurnal_range:Sradmwk), names_to = "Parameter", values_to = "Value")

ggplot(downstream_s_long) + geom_violin(aes(x = Parameter, y = Value)) + facet_wrap(~Parameter, scales = "free")
```

### constrain to "day of water year" when Yolo Bypass gets inundated
```{r}
d.idys = subset(d, d$inundation == 1)
range(d.idys$dowy)
# min "day of water year" 65; max 214

d.idys = subset(d, (d$dowy >= 65 & d$dowy <= 214))
table(d.idys$inundation)
```

### Model

1. try constraining the time series
2. categorize inundation (high, low, no_inundation)
3. year as random effect
4. plots of normalized data
5. plots of response vs. covar
6. residuals mean 0 and variance similar across the range


1. "Days_since_last_inundation"
2. "days_of_inundation_until_now"
3. "total_inund_last_year"
4. "inundation_flag"

Model 0: log_chla = s(Q_sday, by = inundated)
Model 1: log_chla = s(Q_sday, by = inundated) + s(dowy)
Model 2: log_chla = te(Q_sday, dowy, by = inundated)
Model 3: log_chla = te(Q_sday, cumulative_idys, by = inundated (0,1))
Model 4: log_chla = te(Q_sday, dowy, by = inundation level)
Model 5: log_chla = te(Q_sday, dowy, days_since_inundation, by = inundated)


```{r}
gamd0 <- gam(log_chla ~ 1, method = "REML", data = d.idys, family = "gaussian")
gamd1.0 <- gam(log_chla ~ s(log_qsdy, by = inundation), method = "REML", data = d.idys, family = "gaussian")
gamd1.1 <- gam(log_chla ~ s(log_qsdy, by = inundation) + s(dowy, bs = "cc"), method = "REML", data = d.idys, family = "gaussian")
gamd1.2 <- gam(log_chla ~ te(log_qsdy, dowy, by = inundation), method = "REML", data = d.idys, family = "gaussian")
gamd1.3 <- gam(log_chla ~ te(log_idys, dowy, by = inundation), method = "REML", data = d.idys, family = "gaussian")
gamd1.4 <- gam(log_chla ~ te(log_qsdy, dowy, by = inund_fac),  method = "REML", data = d.idys, family = "gaussian")

AIC(gamd0, gamd1.0, gamd1.1, gamd1.2, gamd1.3, gamd1.4)

gam.check(gamd1.1)
gam.check(gamd1.2)
gam.check(gamd1.3)
gam.check(gamd1.4)

summary(gamd1.1)
summary(gamd1.2)
summary(gamd1.3)
summary(gamd1.4)

resid = residuals(gamd1.4)
acf(resid)
pacf(resid)

```

#### Model validation for the gam model based on hypothesis testing

```{r}

  # validate model gamd1.2 - log_chla ~ te(log_qsdy, dowy, by = inundation)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_qsdy.tiff", width = 6, height = 9, units = "in", res = 100)
  resid = residuals(gamd1.2)
  op = par(mfrow = c(3, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamd1.2), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(d.idys$log_qsdy, resid, xlab = "Flow",   ylab = "Residuals")
  plot(d.idys$dowy, resid, xlab = "day of water year",   ylab = "Residuals")
  plot(d.idys$inundation, resid, xlab = "inundation flag",   ylab = "Residuals")
  par(op)
  dev.off()

  # validate model gamd1.3 - log_chla ~ te(log_idys, dowy, by = inundation)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_idys.tiff", width = 8, height = 6, units = "in", res = 100)
  resid = residuals(gamd1.3)
  op = par(mfrow = c(2, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamd1.3), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(d.idys$log_idys, resid, xlab = "Consecutive inundation days",   ylab = "Residuals")
  par(op)
  dev.off()

  # validate model gamd1.4 - log_chla ~ te(log_qsdy, dowy, by = inund_fac)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_qsdy_ifac.tiff", width = 8, height = 10, units = "in", res = 100)
  resid = residuals(gamd1.4)
  op = par(mfrow = c(3, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamd1.4), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(d.idys$log_qsdy, resid, xlab = "Flow same day",   ylab = "Residuals")
  #plot(d.idys$dowy, resid, xlab = "day of water year",   ylab = "Residuals")
  plot(d.idys$inund_fac, resid, xlab = "inundation factor",   ylab = "Residuals")
  plot(d.idys$WTmwk, resid, xlab = "inundation factor",   ylab = "Residuals")
  par(op)
  dev.off()

```

#### Visualize gamd1.2
```{r}

# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.95
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(d.idys$log_qsdy))
#med.dowy = median(d.idys$dowy)
med.dowy = quantile(d.idys$dowy, probs = 0.9)
qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
n = length(qsdy.ser)
new_dat_d1 = data.frame(cbind(log_qsdy = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_d1$inundation = sample(c(0,1), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gamd1.2, newdata = new_dat_d1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_d1 = cbind(new_dat_d1, fit, upper, lower)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# separate by inundation flag
gamd.i0 = subset(new_dat_d1, new_dat_d1$inundation == 0)
gamd.i1 = subset(new_dat_d1, new_dat_d1$inundation == 1)

# plot the actual data points
plot(d.idys$log_chla ~ d.idys$log_qsdy, pch = 20, col = gray(0.1,0.2), las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Flow)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gamd.i0$log_qsdy, max(gamd.i0$log_qsdy), rev(gamd.i0$log_qsdy), gamd.i0$log_qsdy[1]),
        y = c(gamd.i0$lower, gamdd.i0$upper[length(gamd.i0$upper)], rev(gamd.i0$upper), gamd.i0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamd.i0$log_qsdy, y = gamd.i0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gamd.i1$log_qsdy, max(gamd.i1$log_qsdy), rev(gamd.i1$log_qsdy), gamd.i1$log_qsdy[1]),
        y = c(gamd.i1$lower, gamd.i1$upper[length(gamd.i1$upper)], rev(gamd.i1$upper), gamd.i1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamd.i1$log_qsdy, y = gamd.i1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))

```

#### Visualize gamd1.3

```{r}

# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.95
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(d.idys$log_idys))
med.dowy = median(d.idys$dowy)
qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
n = length(qsdy.ser)
new_dat_d1 = data.frame(cbind(log_idys = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_d1$inundation = sample(c(0,1), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gamd1.3, newdata = new_dat_d1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_d1 = cbind(new_dat_d1, fit, upper, lower)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# separate by inundation flag
gamd.i0 = subset(new_dat_d1, new_dat_d1$inundation == 0)
gamd.i1 = subset(new_dat_d1, new_dat_d1$inundation == 1)

# plot the actual data points
plot(d.idys$log_chla ~ d.idys$log_idys, pch = 20, col = gray(0.1,0.2), las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Inundation Days)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gamd.i0$log_idys, max(gamd.i0$log_idys), rev(gamd.i0$log_idys), gamd.i0$log_idys[1]),
        y = c(gamd.i0$lower, gamd.i0$upper[length(gamd.i0$upper)], rev(gamd.i0$upper), gamd.i0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamd.i0$log_idys, y = gamd.i0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gamd.i1$log_idys, max(gamd.i1$log_idys), rev(gamd.i1$log_idys), gamd.i1$log_idys[1]),
        y = c(gamd.i1$lower, gamd.i1$upper[length(gamd.i1$upper)], rev(gamd.i1$upper), gamd.i1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamd.i1$log_idys, y = gamd.i1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))

```



#### Visualize gamd1.4

```{r}

# gamd1.4 <- gam(log_chla ~ te(log_qsdy, dowy, by = inund_fac), method = "REML", data = d.idys, family = "gaussian")


# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.88
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(d.idys$log_qsdy))
med.dowy = median(d.idys$dowy)
qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
n = length(qsdy.ser)
new_dat_d1 = data.frame(cbind(log_qsdy = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_d1$inund_fac = sample(c("none", "long", "short"), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gamd1.4, newdata = new_dat_d1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_d1 = cbind(new_dat_d1, fit, upper, lower)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# separate by inundation flag
gamd.i0 = subset(new_dat_d1, new_dat_d1$inund_fac == "none")
gamd.i1 = subset(new_dat_d1, new_dat_d1$inund_fac == "long")

# plot the actual data points
plot(d.idys$log_chla ~ d.idys$log_qsdy, pch = 20, col = gray(0.1,0.2), las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Flow same day)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gamd.i0$log_qsdy, max(gamd.i0$log_qsdy), rev(gamd.i0$log_qsdy), gamd.i0$log_qsdy[1]),
        y = c(gamd.i0$lower, gamd.i0$upper[length(gamd.i0$upper)], rev(gamd.i0$upper), gamd.i0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamd.i0$log_qsdy, y = gamd.i0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gamd.i1$log_qsdy, max(gamd.i1$log_qsdy), rev(gamd.i1$log_qsdy), gamd.i1$log_qsdy[1]),
        y = c(gamd.i1$lower, gamd.i1$upper[length(gamd.i1$upper)], rev(gamd.i1$upper), gamd.i1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamd.i1$log_qsdy, y = gamd.i1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))

```



## Yolo
### Filter to yolo
```{r}
yolo <- alldata %>% filter(region == "yolo")

yolo_scaled <- yolo %>%
  mutate(across(.cols = c(log_idys,log_qsdy,diurnal_range:Sradmwk), ~ scale(.x)))
  
yo <- yolo_scaled
```

### constrain to "day of water year" when Yolo Bypass gets inundated

```{r}
yo.idys = subset(yo, yo$inundation == 1)
range(yo.idys$dowy)
# min "day of water year" 65; max 214

yo.idys = subset(yo, (yo$dowy >= 82 & yo$dowy <= 215))
table(yo.idys$inundation)
```

### Model
```{r}
gamyo0 <- gam(log_chla ~ 1, method = "REML", data = yo.idys, family = "gaussian")
gamyo1.0 <- gam(log_chla ~ s(log_qsdy, by = inundation), method = "REML", data = yo.idys, family = "gaussian")
gamyo1.1 <- gam(log_chla ~ s(log_qsdy, by = inundation) + s(dowy, bs = "cc"), method = "REML", data = yo.idys, family = "gaussian")
gamyo1.2 <- gam(log_chla ~ te(log_qsdy, dowy, by = inundation), method = "REML", data = yo.idys, family = "gaussian")
gamyo1.3 <- gam(log_chla ~ te(log_idys, dowy, by = inundation), method = "REML", data = yo.idys, family = "gaussian")
gamyo1.4 <- gam(log_chla ~ te(log_qsdy, dowy, by = inund_fac),  method = "REML", data = yo.idys, family = "gaussian")
gamyo1.5 <- gam(log_chla ~ te(log_qsdy, log_idys, dowy),  method = "REML", data = yo.idys, family = "gaussian")
gamyo1.6 <- gam(log_chla ~ te(log_qsdy, dowy), method = "REML", data = yo.idys, family = "gaussian")

AIC(gamyo0, gamyo1.0, gamyo1.1, gamyo1.2, gamyo1.3, gamyo1.4, gamyo1.5, gamyo1.6)

par(mfrow = c(2,2))
gam.check(gamyo1.1)
gam.check(gamyo1.2)
gam.check(gamyo1.3)
gam.check(gamyo1.4)

summary(gamyo1.1)
summary(gamyo1.2)
summary(gamyo1.3)
summary(gamyo1.4)

resid = residuals(gamyo1.4)
acf(resid)
pacf(resid)
```

#### Model validation for the gam model based on hypothesis testing

```{r}

  # validate model gamyo1.2 - log_chla ~ te(log_qsdy, dowy, by = inundation)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_qsdy_yolo.tiff", width = 6, height = 9, units = "in", res = 100)
  resid = residuals(gamyo1.2)
  op = par(mfrow = c(3, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamyo1.2), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(yo.idys$log_qsdy, resid, xlab = "Flow",   ylab = "Residuals")
  plot(yo.idys$dowy, resid, xlab = "day of water year",   ylab = "Residuals")
  plot(yo.idys$inundation, resid, xlab = "inundation flag",   ylab = "Residuals")
  par(op)
  dev.off()

  # validate model gamyo1.4 - log_chla ~ te(log_qsdy, dowy, by = inund_fac)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_qsdy_ifac_yolo.tiff", width = 8, height = 10, units = "in", res = 100)
  resid = residuals(gamyo1.4)
  op = par(mfrow = c(3, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamyo1.4), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(yo.idys$log_qsdy, resid, xlab = "Flow same day",   ylab = "Residuals")
  plot(yo.idys$dowy, resid, xlab = "day of water year",   ylab = "Residuals")
  plot(yo.idys$inund_fac, resid, xlab = "inundation factor",   ylab = "Residuals")
  #plot(yo.idys$WTmwk, resid, xlab = "water temperature",   ylab = "Residuals")
  par(op)
  dev.off()


  # validate model gamyo1.6 - log_chla ~ te(log_qsdy, dowy, by = inundation)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_qsdy_noi_yolo.tiff", width = 6, height = 9, units = "in", res = 100)
  resid = residuals(gamyo1.6)
  op = par(mfrow = c(3, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamyo1.6), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(yo.idys$log_qsdy, resid, xlab = "Flow",   ylab = "Residuals")
  plot(yo.idys$dowy, resid, xlab = "day of water year",   ylab = "Residuals")
  plot(yo.idys$inundation, resid, xlab = "inundation flag",   ylab = "Residuals")
  par(op)
  dev.off()

```

#### Visualize gamyo1.2

```{r}

# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.88
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)
#~ Generate a data frame with the sequence from the minimum to the mayo.imum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(yo.idys$log_qsdy))
lqsdy.05 = quantile(yo.idys$log_qsdy, probs = 0.05)
lqsdy.95 = quantile(yo.idys$log_qsdy, probs = 0.95)
#med.dowy = median(yo.idys$dowy)
med.dowy = quantile(yo.idys$dowy, probs = 0.5)
#qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
qsdy.ser = seq(from = lqsdy.05, to = lqsdy.95, by = 0.02)
n = length(qsdy.ser)
new_dat_yo1 = data.frame(cbind(log_qsdy = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_yo1$inundation = sample(c(0,1), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gam1.2, newdata = new_dat_yo1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_yo1 = cbind(new_dat_yo1, fit, upper, lower)

# separate by inundation flag
gamyo.i0 = subset(new_dat_yo1, new_dat_yo1$inundation == 0)
gamyo.i1 = subset(new_dat_yo1, new_dat_yo1$inundation == 1)

# separate actual data by inundation flag
act.i0 = subset(yo.idys, yo.idys$inundation == 0)
act.i1 = subset(yo.idys, yo.idys$inundation == 1)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# plot the actual data points separately for inundated and non-inundated
colors = c("green", "blue")
plot(yo.idys$log_chla ~ yo.idys$log_qsdy, pch = 20, col = colors[yo.idys$inundation], las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Flow)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gamyo.i0$log_qsdy, max(gamyo.i0$log_qsdy), rev(gamyo.i0$log_qsdy), gamyo.i0$log_qsdy[1]),
        y = c(gamyo.i0$lower, gamyo.i0$upper[length(gamyo.i0$upper)], rev(gamyo.i0$upper), gamyo.i0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue = 255))

# Use the lines() function to add the mean model prediction
lines(x = gamyo.i0$log_qsdy, y = gamyo.i0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gamyo.i1$log_qsdy, max(gamyo.i1$log_qsdy), rev(gamyo.i1$log_qsdy), gamyo.i1$log_qsdy[1]),
        y = c(gamyo.i1$lower, gamyo.i1$upper[length(gamyo.i1$upper)], rev(gamyo.i1$upper), gamyo.i1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamyo.i1$log_qsdy, y = gamyo.i1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))

```



#### Visualize gamyo1.6

```{r}

# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.88
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(yo.idys$log_qsdy))
lqsdy.05 = quantile(yo.idys$log_qsdy, probs = 0.05)
lqsdy.95 = quantile(yo.idys$log_qsdy, probs = 0.95)
#med.dowy = median(yo.idys$dowy)
med.dowy = quantile(yo.idys$dowy, probs = 0.5)
#qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
qsdy.ser = seq(from = lqsdy.05, to = lqsdy.95, by = 0.02)
n = length(qsdy.ser)
new_dat_yo1 = data.frame(cbind(log_qsdy = qsdy.ser, dowy = rep(med.dowy, n)))

#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gam1.6, newdata = new_dat_yo1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_yo1 = cbind(new_dat_yo1, fit, upper, lower)

# separate actual data by inundation flag
act.i0 = subset(yo.idys, yo.idys$inundation == 0)
act.i1 = subset(yo.idys, yo.idys$inundation == 1)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# plot the actual data points separately for inundated and non-inundated
colors = c("green", "blue")
plot(yo.idys$log_chla ~ yo.idys$log_qsdy, pch = 20, col = colors[yo.idys$inundation], las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Flow)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(new_dat_yo1$log_qsdy, max(new_dat_yo1$log_qsdy), rev(new_dat_yo1$log_qsdy), new_dat_yo1$log_qsdy[1]),
        y = c(new_dat_yo1$lower, new_dat_yo1$upper[length(gamyo.i0$upper)], rev(new_dat_yo1$upper), new_dat_yo1$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue = 255))

# Use the lines() function to add the mean model prediction
lines(x = new_dat_yo1$log_qsdy, y = new_dat_yo1$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

```


#### Visualize gamyo1.3

```{r}

# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.95
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(yo.idys$log_idys))
med.dowy = median(yo.idys$dowy)
qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
n = length(qsdy.ser)
new_dat_yo1 = data.frame(cbind(log_idys = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_yo1$inundation = sample(c(0,1), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gam1.3, newdata = new_dat_yo1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_yo1 = cbind(new_dat_yo1, fit, upper, lower)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# separate by inundation flag
gamyo.i0 = subset(new_dat_yo1, new_dat_yo1$inundation == 0)
gamyo.i1 = subset(new_dat_yo1, new_dat_yo1$inundation == 1)

# plot the actual data points
plot(yo.idys$log_chla ~ yo.idys$log_idys, pch = 20, col = gray(0.1,0.2), las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Inundation Days)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gamyo.i0$log_idys, max(gamyo.i0$log_idys), rev(gamyo.i0$log_idys), gamyo.i0$log_idys[1]),
        y = c(gamyo.i0$lower, gamyo.i0$upper[length(gamyo.i0$upper)], rev(gamyo.i0$upper), gamyo.i0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamyo.i0$log_idys, y = gamyo.i0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gamyo.i1$log_idys, max(gamyo.i1$log_idys), rev(gamyo.i1$log_idys), gamyo.i1$log_idys[1]),
        y = c(gamyo.i1$lower, gamyo.i1$upper[length(gamyo.i1$upper)], rev(gamyo.i1$upper), gamyo.i1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamyo.i1$log_idys, y = gamyo.i1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))

```


#### Visualize gamyo1.4

```{r}

# gam1.4 <- gam(log_chla ~ te(log_qsdy, dowy, by = inund_fac), method = "REML", data = yo.idys, family = "gaussian")


# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.88
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(yo.idys$log_qsdy))
med.dowy = median(yo.idys$dowy)
qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
n = length(qsdy.ser)
new_dat_yo1 = data.frame(cbind(log_qsdy = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_yo1$inund_fac = sample(c("none", "long", "short"), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gam1.4, newdata = new_dat_yo1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_yo1 = cbind(new_dat_yo1, fit, upper, lower)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# separate by inundation flag
gamyo.i0 = subset(new_dat_yo1, new_dat_yo1$inund_fac == "none")
gamyo.i1 = subset(new_dat_yo1, new_dat_yo1$inund_fac == "long")

# plot the actual data points
plot(yo.idys$log_chla ~ yo.idys$log_qsdy, pch = 20, col = gray(0.1,0.2), las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Flow same day)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gamyo.i0$log_qsdy, max(gamyo.i0$log_qsdy), rev(gamyo.i0$log_qsdy), gamyo.i0$log_qsdy[1]),
        y = c(gamyo.i0$lower, gamyo.i0$upper[length(gamyo.i0$upper)], rev(gamyo.i0$upper), gamyo.i0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamyo.i0$log_qsdy, y = gamyo.i0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gamyo.i1$log_qsdy, max(gamyo.i1$log_qsdy), rev(gamyo.i1$log_qsdy), gamyo.i1$log_qsdy[1]),
        y = c(gamyo.i1$lower, gamyo.i1$upper[length(gamyo.i1$upper)], rev(gamyo.i1$upper), gamyo.i1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gamyo.i1$log_qsdy, y = gamyo.i1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))

```



## Upstream
```{r}
upstream <- alldata %>% filter(region == "above")
```

### Filter to upstream
```{r}
upstream_scaled <- upstream %>%
  mutate(across(.cols = c(log_idys,t_qsdy,diurnal_range:Sradmwk), ~ scale(.x)))
  
u <- upstream_scaled

upstream_s_long <- pivot_longer(u, cols = c(log_idys,t_qsdy,diurnal_range:Sradmwk), names_to = "Parameter", values_to = "Value")

ggplot(upstream_s_long) + geom_violin(aes(x = Parameter, y = Value)) + facet_wrap(~Parameter, scales = "free")
```

### constrain to "day of water year" when the region has inundation? How do we want to pick dates?

```{r}
u.idys = subset(u, (u$dowy >= 67 & u$dowy <= 214))
table(u.idys$inundation)
```

### Model 
Need different models here, not inundation (maybe season or precip?)
```{r}
gamu0 <- gam(log_chla ~ 1, method = "REML", data = u.idys, family = "gaussian")
gamu1.0 <- gam(log_chla ~ s(log_qsdy), method = "REML", data = u.idys, family = "gaussian")
gamu1.1 <- gam(log_chla ~ s(log_qsdy) + s(dowy, bs = "cc"), method = "REML", data = u.idys, family = "gaussian")
gamu1.2 <- gam(log_chla ~ te(log_qsdy, dowy), method = "REML", data = u.idys, family = "gaussian")
gamu1.3 <- gam(log_chla ~ te(log_qsdy, WTmwk, dowy), method = "REML", data = u.idys, family = "gaussian")
gamu1.4 <- gam(log_chla ~ te(og_qsdy, Sradmwk, dowy),  method = "REML", data = u.idys, family = "gaussian")

AIC(gamu0, gamu1.0, gamu1.1, gamu1.2, gamu1.3, gamu1.4)

par(mfrow = c(2,2))
gam.check(gamu1.1)
gam.check(gamu1.2)
gam.check(gamu1.3)
gam.check(gamu1.4)

summary(gamu1.0)
summary(gamu1.1)
summary(gamu1.2) 
summary(gamu1.3)# best model: 39.4%
summary(gamu1.4)

resid = residuals(gamu1.3)
acf(resid)
pacf(resid)

```



## Cache
### Filter to cache
```{r}
cache <- alldata %>% filter(region == "cache")
```

```{r}
cache_scaled <- cache %>%
  mutate(across(.cols = c(log_idys,t_qsdy,diurnal_range:Sradmwk), ~ scale(.x)))
  
c <- cache_scaled

cache_s_long <- pivot_longer(d, cols = c(log_idys,t_qsdy,diurnal_range:Sradmwk), names_to = "Parameter", values_to = "Value")

ggplot(cache_s_long) + geom_violin(aes(x = Parameter, y = Value)) + facet_wrap(~Parameter, scales = "free")
```

### constrain to "day of water year" when the region has inundation

```{r}
c.idys = subset(c, c$inundation == 1)
range(c.idys$dowy)
# min "day of water year" 67; max 214

c.idys = subset(c, (c$dowy >= 67 & c$dowy <= 214))
table(c.idys$inundation)
```

### Model

```{r}
gamc0 <- gam(log_chla ~ 1, method = "REML", data = c.idys, family = "gaussian")
gamc1.0 <- gam(log_chla ~ s(t_qsdy, by = inundation), method = "REML", data = c.idys, family = "gaussian")
gamc1.1 <- gam(log_chla ~ s(t_qsdy, by = inundation) + s(dowy, bs = "cc"), method = "REML", data = c.idys, family = "gaussian")
gamc1.2 <- gam(log_chla ~ te(t_qsdy, dowy, by = inundation), method = "REML", data = c.idys, family = "gaussian")
gamc1.3 <- gam(log_chla ~ te(log_idys, dowy, by = inundation), method = "REML", data = c.idys, family = "gaussian")
gamc1.4 <- gam(log_chla ~ te(t_qsdy, dowy, by = inund_fac),  method = "REML", data = c.idys, family = "gaussian")

AIC(gamc0, gamc1.0, gamc1.1, gamc1.2, gamc1.3, gamc1.4)

par(mfrow = c(2,2))
gam.check(gamc1.1)
gam.check(gamc1.2)
gam.check(gamc1.3)
gam.check(gamc1.4)

summary(gamc1.0)
summary(gamc1.1)
summary(gamc1.2) # best model: 37.6% deviance explained
summary(gamc1.4)

resid = residuals(gamc1.2)
acf(resid)
pacf(resid)

```

#### Model validation


```{r}

  # validate model gamc1.2 - log_chla ~ te(log_qsdy, dowy, by = inundation)
  # -----------------------------------------------------------------------
  # validate the final model by plotting residuals and save to a tiff
  tiff(filename = "figures/gam_model_validation_qsdy_yolo.tiff", width = 6, height = 9, units = "in", res = 100)
  resid = residuals(gamc1.2)
  op = par(mfrow = c(3, 2), mar = c(5, 4, 1, 2), cex = 1.2)
  # Plot 1: Residuals vs. Fitted values; should be centered around 0
  plot(fitted(gamc1.2), resid, xlab = "Fitted values", ylab = "Residuals")
  # Plot 2: histogram of the residuals; should be centered around 0
  hist(resid, xlab = 'Residuals', main = "")
  # Plot 3: is there autocorrelation in the residuals?
  acf(resid)
  # Plots 4,5,6: the Residuals vs. all the predictors; should be centered around 0
  plot(c.idys$t_qsdy, resid, xlab = "Flow",   ylab = "Residuals")
  plot(c.idys$dowy, resid, xlab = "day of water year",   ylab = "Residuals")
  plot(c.idys$inundation, resid, xlab = "inundation flag",   ylab = "Residuals")
  par(op)
  dev.off()
```

#### Visualize gamc1.2
green = no inundation, blue = inundation
```{r}
# Determine the confidence interval to present in your figure and determine the
# t-distribution value of which to multiply the standard error
interval_value = 0.88
t_distribution_probability = 1.0 - (1-interval_value)/2
CI_factor = qt(t_distribution_probability, Inf)

#~ Generate a data frame with the sequence from the minimum to the maximum
# observed value of the predictor variable: day of water year
mod_q_range = range(na.omit(c.idys$t_qsdy))
lqsdy.05 = quantile(c.idys$t_qsdy, probs = 0.05)
lqsdy.95 = quantile(c.idys$t_qsdy, probs = 0.95)
#med.dowy = median(c.idys$dowy)
med.dowy = quantile(c.idys$dowy, probs = 0.5)
#qsdy.ser = seq(from = mod_q_range[1], to = mod_q_range[2], by = 0.05)
qsdy.ser = seq(from = lqsdy.05, to = lqsdy.95, by = 0.02)
n = length(qsdy.ser)
new_dat_c1 = data.frame(cbind(t_qsdy = qsdy.ser, dowy = rep(med.dowy, n)))
new_dat_c1$inundation = sample(c(0,1), n, replace = TRUE)
                       
#~ Use the *predict()* function to estimate model fit and standard error
preds = predict(gamc1.2, newdata = new_dat_c1, se.fit = TRUE)

# Multiply the standard error fit by the t-distribution value to estimate
# the upper and lower confidence interval limits
fit = preds$fit
upper = fit - CI_factor*preds$se.fit
lower = fit + CI_factor*preds$se.fit

new_dat_c1 = cbind(new_dat_c1, fit, upper, lower)

# separate by inundation flag
gam.ci0 = subset(new_dat_c1, new_dat_c1$inundation == 0)
gam.ci1 = subset(new_dat_c1, new_dat_c1$inundation == 1)

# separate actual data by inundation flag
act.ci0 = subset(c.idys, c.idys$inundation == 0)
act.ci1 = subset(c.idys, c.idys$inundation == 1)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~ Visualize the model
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Plot the raw data and make the axes and labels aesthetically pleasing
par(mfrow = c(1,1), mar = c(2.5, 4.5, 2,4.5) + 0.1, oma = c(1.5,0,0.5,0))

# plot the actual data points separately for inundated and non-inundated
colors = c("green", "blue")
plot(c.idys$log_chla ~ c.idys$t_qsdy, pch = 20, col = colors[c.idys$inundation], las = 1, ylab = "", xlab = "")
#mtext(text = "Log(Chlorophyll-a)", side = 4, line = 3)
mtext(text = expression(log[e]~"(Chlorophyll-a)"), side = 2, line = 2.5)
#y_labs = c(0.0001,0.0003,0.001, 0.003,0.01,0.033,0.1,0.33, 1, 3, 8, 20, 55, 150)[c(T,F)]
#axis(side = 4, at = log(y_labs), labels = y_labs, las=1)
mtext(text = expression(log[e]~"(Flow)"), side = 1, line = 2.25)

# Use the polygon function to add the CI
polygon(x = c(gam.ci0$t_qsdy, max(gam.ci0$t_qsdy), rev(gam.ci0$t_qsdy), gam.ci0$t_qsdy[1]),
        y = c(gam.ci0$lower, gam.ci0$upper[length(gam.ci0$upper)], rev(gam.ci0$upper), gam.ci0$lower[1]), border = NA, 
        col = rgb(20, 200, 20, alpha = 150, maxColorValue = 255))

# Use the lines() function to add the mean model prediction
lines(x = gam.ci0$t_qsdy, y = gam.ci0$fit, lwd = 2, col = rgb(20, 150, 20, alpha = 255, maxColorValue = 255))

# Use the polygon function to add the CI
polygon(x = c(gam.ci1$t_qsdy, max(gam.ci1$t_qsdy), rev(gam.ci1$t_qsdy), gam.ci1$t_qsdy[1]),
        y = c(gam.ci1$lower, gam.ci1$upper[length(gam.ci1$upper)], rev(gam.ci1$upper), gam.ci1$lower[1]), border = NA, 
        col = rgb(20, 20, 200, alpha = 150, maxColorValue=255))

# Use the lines() function to add the mean model prediction
lines(x = gam.ci1$t_qsdy, y = gam.ci1$fit, lwd = 2, col = rgb(20, 20, 150, alpha = 255, maxColorValue = 255))
```

